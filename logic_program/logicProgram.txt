;流操作
(define (stream-append-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
            (stream-car s1)
            (stream-append-delayed  (stream-cdr s1) delayed-s2))))

(define (interleave-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
            (stream-car s1)
            (interleave-delayed  (force delayed-s2) 
                                 (delay (stream-cdr s1))))))

(define (flatten-stream stream)
    (if (stream-null? stream)
        the-empty-stream
        (interleave-delayed
            (stream-car stream)
            (delay (flatten-stream (stream-cdr stream))))))            

(define (stream-flatmap proc stream)
    (flatten-stream (stream-map proc stream)))

(define (singleton-stream x)
    (cons-stream x the-empty-stream))            

;操作的语法过程
(define (type exp)
    (if (pair? exp)
        (car exp)
        (error "Unknown expression TYPE" exp)))

(define (contents exp)
    (if (pair? exp)
        (cdr exp)
        (error "Unknown expression CONTENTS" exp)))

(define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))        

(define (assertion-to-be-added? exp)
    (eq? (type exp) 'assert!))

(define (add-assertion-body exp)
    (car (contents exp)))

(define (empty-conjunction? exps) (null? exps))
(define (first-conjunction exps) (car exps))
(define (rest-conjunction exps) (cdr exps))

(define (empty-disjunction? exps) (null? exps))
(define (first-disjunction exps) (car exps))
(define (rest-disjunction exps) (cdr exps))

(define (negated-query exps) (car exps))

(define (predicate exps) (car exps))
(define (args exps) (cdr exps))

(define (rule? statement)
    (tagged-list? statement 'rule))

(define (conclusion rule)
    (cadr rule))

(define (rule-body rule)
    (if (null? (cddr rule))
        '(always-true)
        (caddr rule)))

(define (var? exp)
    (tagged-list? exp '?))

(define (constant-symbol? exp)
    (not (var? exp)))

(define rule-counter 0)

(define (new-rule-application-id)
    (set! rule-counter (+ rule-counter 1))
    rule-counter)
(define (make-new-variable var rule-application-id)
    (cons '? (cons rule-application-id (cdr var))))
   
(define (contract-question-mark variable)
    variable)
   

;数据库的维护
(define (index-key-of pat)
    (let ((key (car pat)))
         (if (var? key)
             '?
             key)))

(define (use-index? pat)
    (constant-symbol? (car pat)))     

(define (indexable? pat)
    (or (var? (car pat))
        (constant-symbol? (car pat))))                 

    ;建表
(define stream-table-operation (make-table))
(define get (stream-table-operation 'lookup))
(define put (stream-table-operation 'insert!))        
 
 (define (get-stream key1 key2)
    (let ((s (get key1 key2)))
         (if s
             s
             the-empty-stream)))        

(define THE-ASSERTIONS the-empty-stream)
(define (get-indexed-assertions pattern)
    (get-stream (index-key-of pattern) 'assertion-stream))
(define (get-all-assertions) THE-ASSERTIONS)
(define (fetch-assertions pattern frame)
    (if (use-index? pattern)
        (get-indexed-assertions pattern)
        (get-all-assertions)))

(define THE-RULES the-empty-stream)
(define (get-indexed-rules pattern)
    (stream-append
    	 (get-stream (index-key-of pattern) 'rule-stream)
		 (get-stream '? 'rule-stream)))
(define (get-all-rules) THE-RULES)
(define (fetch-rules pattern frame)
    (if (use-index? pattern)
        (get-indexed-rules pattern)
        (get-all-rules)))   

(define (store-assertion-in-index assertion)
    (if (indexable? assertion)
            (let ((key (index-key-of assertion)))
                (let ((current-assertion-stream 
                        (get-stream key 'assertion-stream)))
                       (put key 
                            'assertion-stream
                            (cons-stream assertion
                                        current-assertion-stream))))))            

(define (store-rule-in-index rule)
    (let ((pattern (conclusion rule)))
         (if (indexable? pattern)
             (let ((key (index-key-of pattern)))
                  (let ((current-rule-stream 
                        (get-stream key 'rule-stream)))
                       (put key 
                            'rule-stream
                            (cons-stream rule
                                        current-rule-stream)))))))

(define (add-rule! rule)
    (store-rule-in-index rule)
    (let ((old-rules THE-RULES))
         (set! THE-RULES
                (cons-stream rule old-rules))
         'ok)) 

(define (add-assertion! assertion)
    (store-assertion-in-index assertion)
    (let ((old-assertions THE-ASSERTIONS))
         (set! THE-ASSERTIONS
                (cons-stream assertion old-assertions))
         'ok))                     

(define (add-rule-or-assertion! assertion)
    (if (rule? assertion)
        (add-rule! assertion)
        (add-assertion! assertion)))
;求值器
(define (qeval query frame-stream)
    (let ((qproc (get (type query) 'qeval)))
        (if qproc
            (qproc (contents query) frame-stream)
            (simple-query query frame-stream))))
    ;简单查询
(define (simple-query query-pattern frame-stream)
    (stream-flatmap
        (lambda (frame)
            (stream-append-delayed 
                (find-assertions query-pattern frame)
                (delay (apply-rules query-pattern frame))))
        frame-stream))
	;复合查询     
(define (conjoin conjuncts frame-stream)
    (if (empty-conjunction? conjuncts)
        frame-stream
        (conjoin (rest-conjunction conjuncts)
                 (qeval (first-conjunction conjuncts)
                        frame-stream))))

(put 'and 'qeval conjoin)               

(define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
        the-empty-stream
        (interleave-delayed
            (qeval (first-disjunction disjuncts) frame-stream)
            (delay (disjoin (rest-disjunction disjuncts) frame-stream)))))

(put 'or 'qeval disjoin)   

(define (negate operands frame-stream)
    (stream-flatmap
        (lambda (frame)
                (if (stream-null? (qeval (negated-query operands) 
                                         (singleton-stream frame)))
                    (singleton-stream frame)
                    the-empty-stream))
        frame-stream))

(put 'not 'qeval negate) 

(define (execute exp)
    (apply (eval (predicate exp) user-initial-enviroment)
           (args exp)))


(define (lisp-value call frame-stream)
    (stream-flatmap
        (lambda (frame)
                (if (execute (instantiate call 
                                          frame
                                          (lambda (v f)
                                                  (error "Unknow pat var LISP-VALUE"))))
                    (singleton-stream frame)
                    the-empty-stream))
        frame-stream))

(put 'lisp-value 'qeval lisp-value)    

(define (always-true ignore frame-stream)
    frame-stream)

(put 'always-true 'qeval always-true)    

;框架和约束
(define (make-binding variable value)
    (cons variable value))

(define (binding-variable binding)
    (car binding))

(define (binding-value binding)
    (cdr binding))

(define (binding-in-frame variable frame)
    (assoc variable frame))            

(define (extend variable value frame)
    (cons (make-binding variable value) frame))   

;通过模式匹配找出断言
(define (find-assertions pattern frame)
    (stream-flatmap (lambda (datum) 
                        (check-an-assertion datum pattern frame))
                    (fetch-assertions pattern frame)))

(define (check-an-assertion assertion query-pat query-frame)
    (let ((match-result
            (pattern-match query-pat assertion query-frame)))
        (if (eq? match-result 'failed)
            the-empty-stream
            (singleton-stream match-result))))                    

(define (pattern-match pat dat frame)
    (cond ((eq? frame 'failed) 'failed)
          ((equal? pat dat) frame)
          ((var? pat) (extend-if-consistent pat dat frame))
          ((and (pair? pat) (pair? dat))
           (pattern-match (cdr pat)
                          (cdr dat)
                          (pattern-match (car pat)
                                         (car dat)
                                         frame)))
          (else 'failed)))

(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))

;规则和合一
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))

(define (apply-a-rule rule query-pattern query-frame)
    (let ((clean-rule (rename-variables-in rule)))
        (let ((unify-result 
                (unify-match query-pattern
                                (conclusion clean-rule)
                                query-frame)))
            (if (eq? unify-result 'failed)
                the-empty-stream
                (qeval (rule-body clean-rule)
                       (singleton-stream unify-result)))))) 

(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))

(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame))
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))

(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                     
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)    
           'failed)
          (else (extend var val frame)))))

(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))

;实例化
(define (instantiate exp frame unbound-var-handler)
    (define (copy exp)
        (cond ((var? exp)
                (let ((binding (binding-in-frame exp frame)))
                    (if binding
                        (copy (binding-value binding))
                        (unbound-var-handler exp frame))))
              ((pair? exp)
               (cons (copy (car exp)) (copy (cdr exp))))
              (else exp)))
    (copy exp))

;主循环
(define (query-driver-loop)
    (display ":::Query input:" newline)
    (let ((q (query-syntax-process (read))))
        (cond ((assertion-to-be-added? q)
               (add-rule-or-assertion! (add-assertion-body q))
               (display "Assertion added to data base." newline)
               (query-driver-loop))
               (else (display newline ":::Query output:" newline)
                     (display-stream
                        (stream-map
                            (lambda (frame)
                                (instantiate q
                                            frame
                                            (lambda (v f)
                                            (contract-question-mark v))))
                        (stream-filter 
                        	(lambda (s) (not (stream-null? s)))
                        	(qeval q (singleton-stream '())))))
                     (query-driver-loop)))))
                                        

;测试集
(define dat1 (query-syntax-process (read)))
(job (xie) (computer))
                     
(define dat2 (query-syntax-process (read)))
(job (lu) (mouse))

(define dat3 (query-syntax-process (read)))    
(job (cheng) (keyboard))                
                     
(add-rule-or-assertion! (add-assertion-body (query-syntax-process (read))))
(assert! (job (xie) (computer)))                     
(add-rule-or-assertion! (add-assertion-body (query-syntax-process (read))))
(assert! (job (lu) (mouse)))                     
(add-rule-or-assertion! (add-assertion-body (query-syntax-process (read))))
(assert! (job (cheng) (keyboard)))                     

(define q (query-syntax-process (read)))
(job ?x ?y)   

(define q1 (query-syntax-process (read)))
(job ?x (computer)) 

(define q2 (query-syntax-process (read)))
(lives-near ?x (Bitdiddle Ben))

(define q3 (query-syntax-process (read)))
(and (supervisor ?p ?super) (not (job ?p (computer . ?type))))

(define q4 (query-syntax-process (read)))
(not (job ?p (computer . ?type)))

(define q5 (query-syntax-process (read)))
(supervisor ?p ?super)

(define q6 (query-syntax-process (read)))
(lives-near ?x (Bitdiddle Ben))
      
(define q7 (query-syntax-process (read)))
(append-to-form () (a b) ?z)      
      
(define sing (cons-stream nil nil)) 
              
(define f1 (pattern-match q dat1 nil))   
(define f2 (pattern-match q dat2 nil))   
(define f3 (pattern-match q dat3 nil))

